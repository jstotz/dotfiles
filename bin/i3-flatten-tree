#!/usr/bin/env ruby

require 'json'

def find_nodes(node, found = [], &block)
  found << node if yield node
  node[:nodes].each { |node| find_nodes(node, found, &block) }
  found
end

def find_node(node, &block)
  find_nodes(node, &block).first
end

def transform_tree(node, parent=nil, depth=0, index=0, &block)
  children = node[:nodes]
  new_node = yield node, parent, depth, index
  return new_node if new_node.nil?
  unless new_node.is_a?(Hash)
    raise "New node must be a Hash. Got #{new_node.inspect} (#{new_node.class})"
  end
  new_node[:nodes] = children.map do |child|
    transform_tree(child, new_node, depth + 1, index, &block)
  end.compact
  new_node
end

def walk_tree(node, parent=nil, depth=0, index=0, &block)
  children = node[:nodes]
  result = yield node, parent, depth, index
  children.each do |child|
    walk_tree(child, node, depth + 1, index, &block)
  end
  result
end

def get_tree(&block)
  block ||= ->(node) { node }
  root = JSON.parse(`i3-msg -t get_tree`, symbolize_names: true)
  transform_tree(root, &block)
end

tree = get_tree do |node|
  node.slice(:id, :type, :layout, :orientation).merge((node[:window_properties] || {}).slice(:class, :title))
end

collapsible_nodes = find_nodes(tree) do |node|
  node[:type] == 'con' &&
    node[:nodes].size == 1 &&
    node[:nodes][0].slice(:type, :layout) == node.slice(:type, :layout) &&
    [node[:orientation], 'none'].include?(node[:nodes][0][:orientation])
end

require 'pp'
pp tree

puts '-' * 100

pp collapsible_nodes

puts '-' * 100

collapsible_nodes.each do |node|
  node[:nodes].each do |child|
    puts "Moving node up: #{child.inspect}"
    system "i3-msg '[con_id=\"#{child[:id]}\"] move container up'"
  end
end
